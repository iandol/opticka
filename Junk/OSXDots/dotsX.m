function [frames, rseed, start_time, end_time, response, response_time] = dotsX(screenInfo, dotInfo, targets)%% [frames, rseed, start_time, end_time, response, response_time] =% dotsX(screenInfo, dotInfo, targets)% targets optional.%% arguments - minimum fields for dotInfo and screenInfo - see createDotInfo% and openExperiment%%   most everything is in visual degrees * 10, since rex only likes integers %%       dotInfo.numDotField     number of dot patches that will be shown on the screen%		dotInfo.coh             vertical vectors, dots coherence (0...999) for each dot patch%		dotInfo.speed           vertical vectors, dots speed (10th deg/sec) for each dot patch%		dotInfo.dir             vertical vectors, dots direction (degrees) for each dot patch%       dotInfo.dotSize         size of dots in pixels, same for all patches%       dotInfo.dotColor        color of dots in rgb, same for all patches%       dotInfo.maxDotsPerFrame determined by testing video card%       dotInfo.apXYD           x, y coordinates, and diameter of aperture(s) in visual degrees          %		dotInfo.maxDotTime      optional, can set maximum duration (sec).%		                        if not, dot presentation terminated only by user response%       dotInfo.trialtype       1 fixed duration, 2 reaction time%       dotInfo.keys            a set of keyboard buttons that can%                               terminate the presentation of dots (optional)%       dotInfo.mouse           a set of mouse buttons that can terminate%                               the presentation of dots (optional)%%       screenInfo.curWindow    window on which to plot dots%       screenInfo.center       center of the screen in pixels%       screenInfo.ppd          pixels per visual degree%       screenInfo.monRefresh   monitor refresh value%       screenInfo.dontclear    If set to 1, flip will not clear the framebuffer after Flip - this allows incremental %                               drawing of stimuli. Needs to be zero for dots to be erased.%		screenInfo.rseed        random # seed, can be empty set[] %%       targets structure not necessary if not showing targets with the%       dots%       targets.rects   dimensions for drawOval%       targets.colors  color of targets%       targets.show    optional, if only showing certain targets but don't%            want to change targets structure (index number of target(s) to be%            shown during dots%% algorithm:%		All calculations take place within a square aperture% in which the dots are shown. The dots are constructed in 3 sets that are% plotted in sequence.  For each set, the probability that a dot is% replotted in motion -- as opposed to randomly replaced -- is given by the% dotInfo.coh value.  This routine generates a set of dots as an ndots_ by% 2 matrix of locations, and then plots them.  In plotting the next set of% dots (e.g., set 2) it prepends the preceding set (e.g., set 1).%% created by MKMK July 2006, based on ShadlenDots by MNS, JIG and others% structures are not altered in this function, so should not have memory% problems from matlab creating new structures...% CURRENTLY THERE IS AN ALMOST ONE SECOND DELAY FROM THE TIME DOTSX IS% CALLED UNTIL THE DOTS START ON THE SCREEN! THIS IS BECAUSE OF PRIORITY.% NEED TO EVALUATE WHETHER PRIORITY IS REALLY NECESSARY.%%mfilename%test = GetSecs;if nargin < 3    targets = [];    showtar = [];else    if isfield(targets,'show')        showtar = targets.show;    else        showtar = 1:size(targets.rects,1);    endendcurWindow = screenInfo.curWindow;dotColor = dotInfo.dotColor;rseed = screenInfo.rseed;% this only matters if using mouse, if dotInfo.mouse doesn't exist, this is% never checked.if dotInfo.trialtype(2) == 2    waitpress = 1; % 1 means wait for a mouse presselse    waitpress = 0; % 0 means wait for releaseend% to find out if using keypress or mouse, all trials should have spacekey% for abort, unless its a demo.% spacekey means end experiment after this trial - sends abort message to% experimentkeys = [];abort = [];if isfield(dotInfo, 'keyLeft')    keys = [dotInfo.keyLeft dotInfo.keyRight];elseif isfield(dotInfo, 'keySpace')    abort = nan;end% mouseif isfield(dotInfo, 'mouse')    mouse = dotInfo.mouse;else    mouse = [];endstart_time = NaN;end_time= NaN;response = {NaN, NaN NaN};response_time = NaN;if isfield(targets,'select')    h = targets.select(:,1);    k = targets.select(:,2);    r = targets.select(:,3);end% SEED THE RANDOM NUMBER GENERATOR ... if "[]" is given, reset% the seed "randomly"... this is for VAR/NOVAR conditionsif ~isempty(rseed) && length(rseed) == 1    rand('state', rseed);elseif ~isempty(rseed) && length(rseed) == 2    rand('state', rseed(1)*rseed(2));else    rseed = sum(100*clock);    rand('state', rseed);end% create the square for the apertureapRect = floor(createTRect(dotInfo.apXYD, screenInfo));% USEFUL LOCAL VARS% variables that are sent to rex have been multiplied by a factor of 10 to% make sure they are integers. Now we have to convert them back so that% they are correct for plotting.coh   	= dotInfo.coh/1000;	%  % dotInfo.coh is specified on 0... (because% of rex needing integers), but we want 0..1apD = dotInfo.apXYD(:,3); % diameter of aperture% dotInfo.apXYD(:,1:2)% screenInfo.center;% disp('dotInfo.apXYD')% dotInfo.apXYD(:,1:2)/10*screenInfo.ppdsize(screenInfo.center);center = repmat(screenInfo.center,size(dotInfo.apXYD(:,1)));size(dotInfo.apXYD(:,1:2));% change the xy coordinates to pixels (y is inverted - pos on bottom, neg.% on topcenter = [center(:,1) + dotInfo.apXYD(:,1)/10*screenInfo.ppd center(:,2) - dotInfo.apXYD(:,2)/10*screenInfo.ppd]; % where you want the center of the apertured_ppd 	= floor(apD/10 * screenInfo.ppd);	% size of aperture in pixelsdotSize = dotInfo.dotSize; % probably better to leave this in pixels, but not sure%dotSize = screenInfo.ppd*dotInfo.dotSize/10;% ndots is the number of dots shown per video frame% we will place dots in a square the size of the aperture% - Size of aperture = Apd*Apd/100  sq deg% - Number of dots per video frame = 16.7 dots per sq.deg/sec,%        Round up, do not exceed the number of dots that can be%		 plotted in a video frame (dotInfo.maxDotsPerFrame)% maxDotsPerFrame was originally in setupScreen as a field in screenInfo,% but makes more sense in createDotInfo as a field in dotInfondots 	= min(dotInfo.maxDotsPerFrame, ceil(16.7 * apD .* apD * 0.01 / screenInfo.monRefresh));% don't worry about pre-allocating, the number of dot fields should never% be large enough to cause memory problemsfor df = 1 : dotInfo.numDotField,    % dxdy is an N x 2 matrix that gives jumpsize in units on 0..1    %    	 deg/sec     * Ap-unit/deg  * sec/jump   =   unit/jump    dxdy{df} 	= repmat((dotInfo.speed(df)/10) * (10/apD(df)) * (3/screenInfo.monRefresh) ...        * [cos(pi*dotInfo.dir(df)/180.0) -sin(pi*dotInfo.dir(df)/180.0)], ndots(df),1);    % ARRAYS, INDICES for loop    ss{df}		= rand(ndots(df)*3, 2); % array of dot positions raw [xposition yposition]    % divide dots into three sets...    Ls{df}      = cumsum(ones(ndots(df),3))+repmat([0 ndots(df) ndots(df)*2], ndots(df), 1);    loopi(df)   = 1; 	% loops through the three sets of dotsend;%disp('after one loop')% loop length is determined by the field "dotInfo.maxDotTime"% if none given, loop until "continue_show=0" is set by other means (eg% user response), otherwise loop until dotInfo.maxDotTime% always one video frame per loopif ~isfield(dotInfo,'maxDotTime') || (isempty(dotInfo.maxDotTime) && ndots>0),    continue_show = -1;elseif ndots > 0,    continue_show = round(dotInfo.maxDotTime*screenInfo.monRefresh);else    continue_show = 0;end;dontclear = screenInfo.dontclear;% THE MAIN LOOPframes = 0;priorityLevel = MaxPriority(curWindow,'KbCheck');Priority(priorityLevel);index = 0;% make sure the fixation still onfor i = showtar    Screen('FillOval', screenInfo.curWindow, targets.colors(i,:), targets.rects(i,:));endScreen('DrawingFinished',curWindow,dontclear);% how dots are presented: 1 group of dots are shown in the first frame, a% second group are shown in the second frame, a third group shown in the% third frame, then in the next frame, some percentage of the dots from the% first frame are replotted according to the speed/direction and coherence,% the next frame the same is done for the second group, etc.%GetSecs - testwhile continue_show    for df = 1 : dotInfo.numDotField,        % ss is the matrix with the 3 sets of dot positions, dots from the last 2 positions + current        % Ls picks out the set (for ex., with 5 dots on the screen at a time, 1:5, 6:10, or 11:15)        Lthis{df}  = Ls{df}(:,loopi(df));  % Lthis now has the dot positions from 3 frames ago, which is what is then        % moved in the current loop        this_s{df} = ss{df}(Lthis{df},:); % this is a matrix of random #s - starting positions for dots not moving coherently                % update the loop pointer        loopi(df) = loopi(df)+1;        if loopi(df) == 4,            loopi(df) = 1;        end        % compute new locations, how many dots move coherently        L = rand(ndots(df),1) < coh(df);        this_s{df}(L,:) = this_s{df}(L,:) + dxdy{df}(L,:);	% offset the selected dots        if sum(~L) > 0            this_s{df}(~L,:) = rand(sum(~L),2);	    % get new random locations for the rest        end        % wrap around - check to see if any positions are greater than one or less than zero        % which is out of the square aperture, and then replace with a dot along one        % of the edges opposite from direction of motion.        N = sum((this_s{df} > 1 | this_s{df} < 0)')' ~= 0;        if sum(N) > 0            xdir = sin(pi*dotInfo.dir(df)/180.0);            ydir = cos(pi*dotInfo.dir(df)/180.0);            % flip a weighted coin to see which edge to put the replaced            % dots            if rand < abs(xdir)/(abs(xdir) + abs(ydir))                this_s{df}(find(N==1),:) = [rand(sum(N),1) (xdir > 0)*ones(sum(N),1)];            else                this_s{df}(find(N==1),:) = [(ydir < 0)*ones(sum(N),1) rand(sum(N),1)];            end        end        % convert to stuff we can actually plot        this_x{df} = floor(d_ppd(df) * this_s{df});	% pix/ApUnit                % this assumes that zero is at the top left, but we want it to be        % in the center, so shift the dots up and left, which just means        % adding half of the aperture size to both the x and y direction.        dot_show{df} = (this_x{df} - d_ppd(df)/2)';    end;    % after all computations, flip, this draws dots from previous loop,    % first time through doesn't do anything    Screen('Flip', curWindow,0,dontclear);    % setup the mask - we will only be able to see a circular aperture,    % although dots moving in a square aperture. Minimizes the edge    % effects.    Screen('BlendFunction', curWindow, GL_ONE, GL_ZERO);    % want targets to still show up    Screen('FillRect', curWindow, [0 0 0 255]);        for df = 1 : dotInfo.numDotField,        % square that dots do not show up in        Screen('FillRect', curWindow, [0 0 0 0], apRect(df,:));        % circle that dots do show up in        Screen('FillOval', curWindow, [0 0 0 255], apRect(df,:));    end        Screen('BlendFunction', curWindow, GL_DST_ALPHA, GL_ONE_MINUS_DST_ALPHA);    % now do actual drawing commands, although nothing drawn until next    % loop    % dots    for df = 1:dotInfo.numDotField        Screen('DrawDots', curWindow, dot_show{df}, dotSize, dotColor, center(df,:),2);    end;	 	 Screen('DrawText', curWindow,sprintf('Frame: %i',frames),400,300,[255 255 255]);        % targets    for i = showtar        Screen('FillOval', screenInfo.curWindow, targets.colors(i,:), targets.rects(i,:));    end     % tell ptb to get ready while doing computations for next dots    % presentation    Screen('DrawingFinished',curWindow,dontclear);    Screen('BlendFunction', curWindow, GL_ONE, GL_ZERO);    frames = frames + 1;        if frames == 1,     start_time = GetSecs;       end;    for df = 1 : dotInfo.numDotField,        % update the dot position array for the next loop        ss{df}(Lthis{df}, :) = this_s{df};    end;    % check for end of loop    continue_show = continue_show - 1;    %user may terminate the dots by pressing certain keyboard keys defined    %by "keys"        % this is changed so now pressing the space bar will cause a signal to    % be sent so that the experiment will end after this trial    if ~isempty(keys),        [keyIsDown,secs,keyCode] = KbCheck;        if keyIsDown,            % send abort signal            if keyCode(abort)                response{1} = find(keyCode(abort))            end            % end trial, have response            if any(keyCode(keys)),                response{3} = find(keyCode(keys));                continue_show = 0;                response_time = secs;            end;        end;    end;    if ~isempty(mouse),        [x,y,buttons] = GetMouse(curWindow);        % check = 0 means exit dots, check = 1 means continue showing dots        check = 0;        if buttons            % mouse was pressed, if hold is on, and we know fixation            % position, make sure holding correct place             if waitpress == 0                if isfield(targets,'select')                    check = checkPosition(x,y,h(1),k(1),r(1));                end            else                % if hold is not on, and this is fixed duration, we don't                % care if the subject touches the screen - if reaction                % time, then touching means exit dots                if dotInfo.trialtype(1) == 1                    check = 1;                end            end            else            % mouse was not pressed.            % if waiting for a mouse press, continue paradigm            if waitpress == 1                check = 1;            end        end        if ~check            % for fixed duration, exiting early is always an error.            if dotInfo.trialtype(1) == 1                response{2} = 0;            else                % buttons is zero if we are doing reaction time where the                % subject has to hold during fixation, and releasing the                % mouse signifies end of the dots, otherwise should tell                % you the xy position. Eventually, I guess we should make                % it so we can use two mouse buttons as the answer...                if buttons                    response{2} = [x y];                    %response{2} = find(buttons(mouse));                else                    response{2} = 0;                end            end            response_time = GetSecs;            continue_show = 0;        end;    endend% present last frame of dotsScreen('Flip', curWindow,0,dontclear);% erase last dots, but leave up fixation and targets (if targets are up)% make sure the fixation still onshowTargets(screenInfo, targets, showtar);%showtarend_time = GetSecs;Priority(0);