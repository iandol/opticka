	classdef getDensity < handle
	%GETDENSITY computes bootstrapped density estimates and full stats for two
	%groups. You can pass a set of cases to the function and it will compute
	%statistics automagically for all cases as well. There are numerous
	%settings:
	% x - our first data group, plotted along the abscissa
	% y - our second data group, plotted along the ordinate
	% nboot - number of bootstrap iterations default: 1000
	% fhandle - function handle to bootstrap default: @mean
	% alpha - P value to use for all statistics
	% legendtxt - A cell list of the main X and Y data, i.e. {'Control','Drug'}
	% dogauss - Add gaussian fits to the histograms? default: true
	% columnlabels - if X/Y have more than 1 column, you can detail column names here
	% dooutlier - remove outliers using 'grubb', 'rosner', 3SD' or 'none'
	% addjitter - add jitter to scatterplot? 'x', 'y', 'both', 'equal', 'none'
	% cases - a celllist of case names the same length as X/Y
	% jitterfactor - how much to scale the jitter, larger values = less jitter
	% showoriginalscatter - show unjittered data too?
	
	properties
		%> comments to add to this data comparison
		comments = {''}
		%> our first data group, plotted along the abscissa
		x = []
		%> our second data group, plotted along the ordinate
		y = []
		%> number of bootstrap iterations default: 1000
		nboot = 1000
		%> function handle to bootstrap default: @mean
		fhandle = @mean
		%> P value to use for all statistics
		alpha = 0.05
		%> A cell list of the main X and Y data, i.e. {'Control','Drug'}
		legendtxt = {'Group1','Group2'}
		%> Add gaussian fits to the histograms? default: true
		dogauss = true
		%> if X/Y have more than 1 column, you can detail column names here
		columnlabels = {'DataSet1'}
		%> add jitter to scatterplot? 'x', 'y', 'both', 'equal', 'none'
		addjitter = 'none'
		%>  celllist of case names the same length as X/Y
		cases = []
		%> are our cases nominal or ordinal?
		nominalcases = true
		%> a cell of names for each row
		xrownames = []
		%> a cell of names for each row
		yrownames = []
		%> remove outliers using 'grubb', 'rosner', 'limit', '3SD' or 'none'
		dooutlier = 'none'
		%> rosner outlier number of outliers
		rosnern = 2
		%> p to use for outlier removal for rosner and grubb
		outlierp = 0.001
		%> outlier limit for limit method
		outlierlimit = Inf
		%> scalefactor for jitter of scatter plot
		jitterfactor = 100
		%> do we spit out each plot in its own figure for easy export?
		singleplots = false
		%> do we show the original points in the scatter before scattering them?
		showoriginalscatter = false
		%> if we are passed data on construction, run straight away
		autorun = false
		%> how to plot the histogram
		bartype = 'grouped'
		%> width of histogram bars
		barwidth = 1.75
		%> are we verbose printing to command line?
		verbose = true
		%> any comments to add to the object
		comment = ''
		%> do we scale the axes to be equal for the scatterplots
		scaleaxes = true
		%> do we show the unity line for the scatterplot?
		showunityline = true
		%>number of bins for histogram
		nBins = 10
		%> centre histogram bins
		centreBins = true
		%>density kernel to use, 'normal', 'box', 'triangle', 'epanechnikov'
		densityKernel = 'normal'
		%> density function, 'pdf', 'cdf','icdf', 'survivor', 'cumhazard'
		densityFunction = 'pdf'
		%> density bounds; 'unbounded', 'positiive' or 2-element vector for lower and upper
		densityBounds = 'unbounded'
		%> for multiple columns only run a subset; empty runs all.
		index = []
		%> normalise (Z-score) values to plot on scatter?
		normaliseScatter = false;
	end
	
	properties (Dependent = true, SetAccess = private, GetAccess = public)
		%> is the x and y data groups equal length, suggestive of paired data?
		isDataEqualLength = true;
		%> number of columns
		nColumns = []
		%> the unique cases
		uniquecases = []
	end
	
	properties (Dependent = true, SetAccess = private, GetAccess = private)
		%> the layout when plotting mutliple plots
		plotX = 3
		%> layout when plotting mutliple plots
		plotY = 2
	end
	
	properties (SetAccess = private, GetAccess = public)
		%> the structure returned from run, saved here
		runStructure
		%> autogenerated dataset for first group
		xdata = []
		%> autogenerated dataset for second group
		ydata = []
	end
	
	properties (SetAccess = private, GetAccess = private)
		%> our panel object, we use panel instead of subplot as it is more powerful
		pn
		workindex
		allowedProperties = []
		ignoreProperties = '(isDataEqualLength|nColumns|uniquecases|runStructure|h|pn|plotX|plotY)';
	end
	
	events (Hidden = false, ListenAccess = private, NotifyAccess = private)
		checkData %trigger this event to perform checks on data and cases etc.
	end
	
	%=======================================================================
	methods %------------------PUBLIC METHODS
		%=======================================================================
		
		% ===================================================================
		%> @brief Class constructor
		%>
		%> More detailed description of what the constructor does.
		%>
		%> @param args are passed as a structure of properties which is
		%> parsed.
		%> @return instance of class.
		% ===================================================================
		function obj = getDensity(varargin)
			
			addlistener(obj,'checkData',@obj.doCheckData); %use an event to keep data accurate
			
			if nargin>0
				obj.parseArgs(varargin, obj.allowedProperties);
			end
			
			if obj.autorun == true && obj.haveData == true
				obj.run;
			end
		end
		
		% ===================================================================
		%> @brief Our main RUN method
		%>
		%> This performs the analysis and plots the results for the stored data.
		%>
		%> @param obj the class object automatically passed in
		%> @return outs a structure with the analysis results if needed.
		% ===================================================================
		function outs = run(obj)
			notify(obj,'checkData');
			if isempty(obj.x)
				error('You haven''t supplied any data yet!')
			end
			warning('off', 'stats:lillietest:OutOfRangePLow')
			warning('off', 'stats:lillietest:OutOfRangePHigh')
			warning('off', 'stats:jbtest:PTooSmall')
			warning('off', 'stats:jbtest:PTooBig')
			if ~isempty(obj.index)
				nVals = length(obj.index);
				obj.workindex = obj.index;
			else
				nVals = size(obj.x,2);
				obj.workindex = 1:nVals;
			end
			for i = 1:nVals
				idx=obj.workindex(i);
				tic
				xcol=obj.x(:,idx);
				ycol=obj.y(:,idx);
				c1 = [0.2 0.2 0.2];
				c2 = [0.8 0.2 0.2];
				casesLocal = obj.cases;
				uniquecases = obj.uniquecases;
				
				outs.x = obj.x;
				outs.y = obj.y;
				outs.cases = casesLocal;
				
				xouttext='';
				youttext='';
				
				fieldn = obj.columnlabels{idx};
				fieldn = regexprep(fieldn,'\s+','_');
				
				h=figure;
				outs.(fieldn).h = h;
				set(h,'Color',[1 1 1]);
				if exist('figpos'); figpos(1,[1200 1200]); end
				t = [obj.columnlabels{:}];
				set(h,'name',t);
				
				pn = panel(h);
				if obj.isDataEqualLength == false
					figpos(1,[1000,1000]);
					delete(gca)
					pn.pack('v',[0.5 0.5]);
					pn(1).pack('h',[1/3 1/3 -1])
					pn(2).pack('h',[1/3 -1])
				else
					figpos(1,[1200,1000]);
					delete(gca)
					pn.pack('v',[0.5 0.5]);
					pn(1).pack('h',[1/3 1/3 -1])
					pn(2).pack('h',[1/3 1/3 -1])
				end
				
				if any(isnan(xcol)) %remove any nans
					xcol(isnan(xcol))=[];
				end
				if any(isnan(ycol))
					ycol(isnan(ycol))=[];
				end
				
				[xcol,ycol,casesLocal,xouttext,youttext] = obj.removeOutliers(xcol,ycol,casesLocal,xouttext,youttext);
				
				isDataEqualLength = false;
				if length(xcol) == length(ycol)
					isDataEqualLength = true;
				end
				
				xmean=nanmean(xcol);
				xmedian=nanmedian(xcol);
				ymean=nanmean(ycol);
				ymedian=nanmedian(ycol);
				xstd=nanstd(xcol);
				ystd=nanstd(ycol);
				xstderr=obj.stderr(xcol,'SE',1);
				ystderr=obj.stderr(ycol,'SE',1);
				
				%==========================================DO HISTOGRAM
				px = 1;
				py = 1;
				pn(py,px).select();
				
				if ystd > 0
					outs.(fieldn).histo1 = histogram(xcol);
					outs.(fieldn).histo1.FaceColor = c1;
					xn = outs.(fieldn).histo1.Values;
					hbinsx = outs.(fieldn).histo1.BinEdges;
					hold on
					outs.(fieldn).histo2 = histogram(ycol);
					outs.(fieldn).histo2.FaceColor = c2;
					yn = outs.(fieldn).histo2.Values;
					hbinsy = outs.(fieldn).histo2.BinEdges;
				else
					outs.(fieldn).histo1 = histogram(xcol);
					outs.(fieldn).histo1.FaceColor = c1;
					xn = outs.(fieldn).histo1.Values;
					hbinsx = outs.(fieldn).histo1.BinEdges;
				end
				
				axis tight;
				ticks out
				lim=ylim;
				text(xmean,lim(2),'\downarrow','Color',c1,'HorizontalAlignment','center',...
					'VerticalAlignment','bottom','FontSize',15,'FontWeight','bold');
				text(xmedian,lim(2),'\nabla','Color',c1,'HorizontalAlignment','center',...
					'VerticalAlignment','bottom','FontSize',15,'FontWeight','bold');
				if ystd > 0
					text(ymean,lim(2),'\downarrow','Color',c2,'HorizontalAlignment','center',...
						'VerticalAlignment','bottom','FontSize',15,'FontWeight','bold');
					text(ymedian,lim(2),'\nabla','Color',c2,'HorizontalAlignment','center',...
						'VerticalAlignment','bottom','FontSize',15,'FontWeight','bold');
				end
				if obj.dogauss == true
					hold on
					if length(find(xn>0))>1
						try
							f1=fit(hbinsx',xn','gauss1');
							plot(f1,'k');
						catch
							disp('Couldn''t fit gaussian to histogram 1')
						end
					end
					if ystd > 0 && length(find(yn>0))>1
						try
							f2=fit(hbinsy',yn','gauss1');
							plot(f2,'r');
						catch
							disp('Couldn''t fit gaussian to histogram 2')
						end
					end
					legend off
					hold off
				end
				
				grid on
				pn(py,px).xlabel(obj.columnlabels{idx});
				pn(py,px).ylabel('Number of cells');
				pn(py,px).title('Histogram and Gaussian Fits');
				
				
				%==========================================DO BOX PLOTS
				px = 2;
				py = 1;
				pn(py,px).select()
				if isDataEqualLength && exist('distributionPlot','file')
					hold on
					distributionPlot({xcol,ycol},0.3);
				elseif isDataEqualLength==false && exist('distributionPlot','file')
					hold on
					distributionPlot({xcol,ycol},0.3);
				end
				if isDataEqualLength
					boxplot([xcol ycol],'positions',[1 2],'notch',1,'whisker',1,...
						'labels',obj.legendtxt,'colors','k',...
						'boxstyle','outline','medianstyle','line',...
						'widths',0.5,'symbol','ro');
				else
					boxplot(xcol,'positions',1,'notch',1,'whisker',1,...
						'labels',obj.legendtxt{1},'colors','k',...
						'boxstyle','outline','medianstyle','line',...
						'widths',0.5,'symbol','ro');
					boxplot(ycol,'positions',2,'notch',1,'whisker',1,...
						'labels',obj.legendtxt{2},'colors','k',...
						'boxstyle','outline','medianstyle','line',...
						'widths',0.5,'symbol','ro');
				end
				pn(py,px).ylabel(obj.columnlabels{idx});
				axis tight
				ticks out
				xlim([0.5 2.5])
				set(gca,'XTick', [1 2],'XTickLabel', obj.legendtxt)
				pn(py,px).title('Box / Density Plots')
				hold off
				box on
				grid on
				yl1 = ylim; %we check this against the next plot below
				
				%==========================================DO SCATBOX PLOTS
				px = 3;
				py = 1;
				pn(py,px).select()
				
				if isDataEqualLength && exist('notBoxPlot','file')
					% 					if ~isempty(uniquecases) && ~isempty(casesLocal)
					% 						for jj = 1:length(uniquecases)
					% 							caseidx = ismember(casesLocal,uniquecases{jj});
					% 							xtmp(:,jj) = xcol(caseidx);
					% 							ytmp(:,jj) = ycol(caseidx);
					% 						end
					% 						notBoxPlot([xtmp ytmp],[1 1 2 2]);
					% 					else
					% 						notBoxPlot([xcol ycol],[1 1]);
					% 					end
					notBoxPlot([xcol ycol],[1 2]);
					set(gca,'XTick', [1 2],'XTickLabel', obj.legendtxt)
					pn(py,px).ylabel(obj.columnlabels{idx});
					
				elseif isDataEqualLength==false && exist('notBoxPlot','file')
					
					notBoxPlot(xcol,1);
					hold on
					notBoxPlot(ycol,2);
					set(gca,'XTick', [1 2],'XTickLabel', obj.legendtxt)
					pn(py,px).ylabel(obj.columnlabels{idx});
					
				end
				xlim([0 3]);
				pn(py,px).title('ScatterBox Plots')
				hold off
				ticks out
				box on
				grid on
				yl2 = ylim;
				
				%==========================================EQUALISE Y AXIS
				ym1 = min([yl1(1) yl2(1)]);
				ym2 = max([yl1(2) yl2(2)]);
				pn(1,2).select()
				ylim([ym1 ym2]);
				pn(1,3).select()
				ylim([ym1 ym2]);
				
				%==========================================DO Correlation SCATTER
				xcolout = xcol;
				ycolout = ycol;
				if ystd > 0 && isDataEqualLength
					px = 1;
					py = 2;
					pn(py,px).select()
					[r,p]=corr(xcol,ycol);
					[r2,p2]=corr(xcol,ycol,'type','spearman');
					
					xrange = max(xcol) - min(xcol);
					yrange = max(ycol) - min(ycol);
					range = max(xrange,yrange);
					
					
					if obj.addjitter == true
						obj.addjitter = 'both';
					end
					switch obj.addjitter
						case 'x'
							sc = true;
							xcolout = obj.jitterData(xcol);
							ycolout = ycol;
						case 'y'
							sc = true;
							xcolout = xcol;
							ycolout = obj.jitterData(ycol);
						case 'equal'
							sc = true;
							[xcolout,jitter] = obj.jitterData([xcol ycol]);
							ycolout = obj.jitterData([ycol xcol],jitter);
						case 'both'
							sc = true;
							xcolout = obj.jitterData(xcol);
							ycolout = obj.jitterData(ycol);
						otherwise
							sc = false;
							xcolout = xcol;
							ycolout = ycol;
					end
					if obj.normaliseScatter == true
						xcolout = zscore(xcolout);
						ycolout = zscore(ycolout);
						mn = min(min(zscore(xcol)),min(zscore(ycol)));
						mx = max(max(zscore(xcol)),max(zscore(ycol)));
					else
						mn = min(min(xcol),min(ycol));
						mx = max(max(xcol),max(ycol));
					end
					if obj.scaleaxes == true
						axrange = [(mn - (mn/20)) (mx + (mx/20)) (mn - (mn/20)) (mx + (mx/20))];
					else
						axrange = [min(xcol) min(xcol)+range min(ycol) min(ycol)+range];
					end
					if ~isempty(casesLocal)
						t = 'Group: ';
						for jj = 1:length(uniquecases)
							t = [t num2str(jj) '=' uniquecases{jj} ' '];
						end
					else
						colours = [0 0 0];
						t = '';
					end
					
					hold on
					if ~isempty(casesLocal)
						gscatter(xcolout,ycolout,casesLocal,'krbgmyc','o');
					else
						scatter(xcolout,ycolout,repmat(80,length(xcol),1),[0 0 0]);
					end
					try %#ok<TRYNC>
						h = lsline;
						set(h,'LineStyle','--','LineWidth',2)
						if obj.showunityline == true
							if abs(r2) < 0.1
								h = line([mn mx],[mn mx]);
								set(h,'Color',[0.7 0.7 0.7],'LineStyle','-.','LineWidth',2)
								h = line([mx mn],[mn mx]);
								set(h,'Color',[0.7 0.7 0.7],'LineStyle','-.','LineWidth',2)
							elseif r2 >= 0
								h = line([mn mx],[mn mx]);
								set(h,'Color',[0.7 0.7 0.7],'LineStyle','-.','LineWidth',2)
							else
								h = line([mx mn],[mn mx]);
								set(h,'Color',[0.7 0.7 0.7],'LineStyle','-.','LineWidth',2)
							end
						end
					end
					if sc == true && obj.showoriginalscatter == true
						scatter(xcol,ycol,repmat(80,length(xcol),1),'ko','MarkerEdgeColor',[0.7 0.7 0.7]);
					end
					axis square
					axis(axrange);
					if obj.scaleaxes == true
						set(gca,'XTick',get(gca,'YTick'),'XTickLabel',get(gca,'YTickLabel'));
					end
					if obj.normaliseScatter == true
						pn(py,px).xlabel(['ZScore ' obj.legendtxt{1}])
						pn(py,px).ylabel(['ZScore ' obj.legendtxt{2}])
					else
						pn(py,px).xlabel(obj.legendtxt{1})
						pn(py,px).ylabel(obj.legendtxt{2})
					end
					pn(py,px).title(['Prson:' sprintf('%0.2g',r) '(p=' sprintf('%0.4g',p) ') | Spman:' sprintf('%0.2g',r2) '(p=' sprintf('%0.4g',p2) ') ' t]);
					hold off
					grid on
					ticks out
					box on
					set(gca,'Layer','top');
				end
				

				
				%============================Lets measure statistics
				t=['Mn/Mdn: ' sprintf('%0.3g', xmean) '\pm' sprintf('%0.3g', xstderr) '/' sprintf('%0.3g', xmedian) ' | ' sprintf('%0.3g', ymean) '\pm' sprintf('%0.3g', ystderr) ' / ' sprintf('%0.3g', ymedian)];
				
				if ystd > 0
					if length(xcol) == length(ycol)
						[h,p1]=ttest2(xcol,ycol,obj.alpha);
					else
						[h,p1]=ttest2(xcol,ycol,obj.alpha);
					end
					[p2,h]=ranksum(xcol,ycol,'alpha',obj.alpha);
					if isDataEqualLength
						[h,p3]=ttest(xcol,ycol,obj.alpha);
						[p4,h]=signrank(xcol,ycol,'alpha',obj.alpha);
						[p5,h]=signtest(xcol,ycol,'alpha',obj.alpha);
					else
						p3 = [];
						p4 = [];
						p5 = [];
					end
					[h,p6]=jbtest(xcol,obj.alpha);
					[h,p7]=jbtest(ycol,obj.alpha);
					if length(xcol)>4
						[h,p8]=lillietest(xcol);
					else
						p8=NaN;
					end
					if length(ycol)>4
						[h,p9]=lillietest(ycol);
					else
						p9=NaN;
					end
					[h,p10]=kstest2(xcol,ycol,obj.alpha);
				else
					[h,p1]=ttest(xcol,obj.alpha);
					[p2,h]=signrank(xcol,0,'alpha',obj.alpha);
					p3=[];
					p4=[];
					[p5,h]=signtest(xcol,0,'alpha',obj.alpha);
					[h,p6]=jbtest(xcol,obj.alpha);
					p7=0;
					if length(xcol)>4
						[h,p8]=lillietest(xcol);
					else
						p8=NaN;
					end
					p9=[];
					p10=kstest(xcol);
				end
				
				outs.(fieldn).ttest = p1;
				outs.(fieldn).ranksum = p2;
				outs.(fieldn).ttest2 = p3;
				outs.(fieldn).signrank = p4;
				outs.(fieldn).signtest = p5;
				outs.(fieldn).jbtestx = p6;
				outs.(fieldn).jbtesty = p7;
				outs.(fieldn).lillietestx = p8;
				outs.(fieldn).lillietesty = p9;
				outs.(fieldn).kstest = p10;
				
				t=[t '\newlineT-test: ' sprintf('%0.3g', p1) '\newline'];
				t=[t 'Wilcox: ' sprintf('%0.3g', p2) '\newline'];
				if exist('p3','var') && ystd > 0
					t=[t 'Pair ttest: ' sprintf('%0.3g', p3) '\newline'];
					t=[t 'Pair wilcox: ' sprintf('%0.3g', p4) '\newline'];
					t=[t 'Pair sign: ' sprintf('%0.3g', p5) '\newline'];
				elseif exist('p5','var')
					t=[t 'Sign: ' sprintf('%0.3g', p5) '\newline'];
				end
				t=[t 'Jarque-Bera: ' sprintf('%0.3g', p6) ' / ' sprintf('%0.3g', p7) '\newline'];
				t=[t 'Lilliefors: ' sprintf('%0.3g', p8) ' / ' sprintf('%0.3g', p9) '\newline'];
				t=[t 'KSTest: ' sprintf('%0.3g', p10) '\newline'];
				
				[xci,xmean,xpop]=bootciold(obj.nboot,{obj.fhandle,xcol},'alpha',obj.alpha);
				[yci,ymean,ypop]=bootciold(obj.nboot,{obj.fhandle,ycol},'alpha',obj.alpha);
				
				try
					[xxci,xxmean,xxpop]=bootciold(obj.nboot,{@median,xcol},'alpha',obj.alpha);
					[yyci,yymean,yypop]=bootciold(obj.nboot,{@median,ycol},'alpha',obj.alpha);
				end
				try
					[xxxci,xxxmean,xxxpop]=bootciold(obj.nboot,{@geomean,xcol},'alpha',obj.alpha);
					[yyyci,yyymean,yyypop]=bootciold(obj.nboot,{@geomean,ycol},'alpha',obj.alpha);
				end
				
				t=[t 'BootStrap: ' sprintf('%0.3g', xci(1)) ' < ' sprintf('%0.3g', xmean) ' > ' sprintf('%0.3g', xci(2)) ' | ' sprintf('%0.3g', yci(1)) ' < ' sprintf('%0.3g', ymean) ' > ' sprintf('%0.3g', yci(2))];
				if exist('xxci','var') && exist('yyci','var')
					t=[t '\newlineMedian BS: ' sprintf('%0.3g', xxci(1)) ' < ' sprintf('%0.3g', xxmean) ' > ' sprintf('%0.3g', xxci(2)) ' | ' sprintf('%0.3g', yyci(1)) ' < ' sprintf('%0.3g', yymean) ' > ' sprintf('%0.3g', yyci(2))];
				end
				if exist('xxxci','var') && exist('yyyci','var')
					t=[t '\newlineGeomean BS: ' sprintf('%0.3g', xxxci(1)) ' < ' sprintf('%0.3g', xxxmean) ' > ' sprintf('%0.3g', xxxci(2)) ' | ' sprintf('%0.3g', yyyci(1)) ' < ' sprintf('%0.3g', yyymean) ' > ' sprintf('%0.3g', yyyci(2))];
				end
				
				[fx,xax]=ksdensity(xpop, 'kernel', obj.densityKernel,...
					'function', obj.densityFunction, 'support', obj.densityBounds);
				[fy,yax]=ksdensity(ypop, 'kernel', obj.densityKernel,...
					'function', obj.densityFunction, 'support', obj.densityBounds);
				
				%==========================================DO CDF
				if isDataEqualLength
					px = 2;
					py = 2;
				else
					px = 1;
					py = 2;
				end
				pn(py,px).select();
				
				% 				h = cdfplot(xcol);
				% 				set(h,'Color',[0 0 0])
				% 				hold on
				% 				h = cdfplot(ycol);
				% 				set(h,'Color',[1 0 0])
				% 				hold off
				hold on
				[f,x,flo,fup] = ecdf(xcol,'alpha',obj.alpha);
				stairs(x,f,'k','LineWidth',2);
				stairs(x,flo,'k:');
				stairs(x,fup,'k:');
				[f,x,flo,fup] = ecdf(ycol,'alpha',obj.alpha);
				stairs(x,f,'r','LineWidth',2);
				stairs(x,flo,'r:');
				stairs(x,fup,'r:');
				hold off
				
				grid on
				ticks out
				box on
				pn(py,px).title(['Cumulative Distribution Function, p=' num2str(obj.alpha)]);
				pn(py,px).xlabel(obj.columnlabels{idx});
				
				%==========================================Do DENSITY
				if isDataEqualLength
					px = 3;
					py = 2;
				else
					px = 2;
					py = 2;
				end
				pn(py,px).select();
				plot(xax,fx,'k-','linewidth',1.5);
				if ystd > 0
					hold on
					plot(yax,fy,'r-','linewidth',1.5);
					hold off
				end
				axis tight
				title(['BootStrap Density Plots; using: ' func2str(obj.fhandle)]);
				box on
				grid on
				ticks out
				set(gca,'Layer','top');
				
				supt=[obj.columnlabels{idx} ' # = ' num2str(length(xcol)) '[' num2str(length(obj.x(:,i))) '] & ' num2str(length(ycol)) '[' num2str(length(obj.y(:,i))) ']'];
				
				if ~isempty(xouttext) && ~strcmp(xouttext,' ') && length(xouttext)<25
					supt=[supt ' | ' obj.dooutlier ': 1 = ' xouttext];
				end
				if ~isempty(youttext) && ~strcmp(youttext,' ') && length(xouttext)<25
					supt=[supt ' | 2 = ' youttext];
				end
				
				h = suptitle(supt);
				set(h,'FontName','Consolas','FontSize',16,'FontWeight','bold')
				
				xl=xlim;
				yl=ylim;
				
				xfrag=(xl(2)-xl(1))/40;
				yfrag=(yl(2)-yl(1))/40;
				
				h=line([xci(1),xmean,xci(2);xci(1),xmean,xci(2);],[yl(1),yl(1),yl(1);yl(2),yl(2),yl(2)]);
				set(h,'Color',[0.5 0.5 0.5],'LineStyle','--');
				
				h=line([yci(1),ymean,yci(2);yci(1),ymean,yci(2);],[yl(1),yl(1),yl(1);yl(2),yl(2),yl(2)]);
				set(h,'Color',[1 0.5 0.5],'LineStyle',':');
				
				text(xl(1)+xfrag,yl(2)-yfrag,t,'FontSize',13,'FontName','Consolas','FontWeight','bold','VerticalAlignment','top');
				%legend(obj.legendtxt);
				
				pn.select('all')
				pn.fontname = 'Helvetica';
				pn.fontsize = 12;
				pn.margin = 20;
				
				outs.(fieldn).pn = pn;
				outs.(fieldn).xcol = xcol;
				outs.(fieldn).ycol = ycol;
				outs.(fieldn).xmean = xmean;
				outs.(fieldn).xmedian = xmedian;
				outs.(fieldn).xstd = xstd;
				outs.(fieldn).xse = xstderr;
				outs.(fieldn).xci = xci;
				outs.(fieldn).ymean = ymean;
				outs.(fieldn).ymedian = ymedian;
				outs.(fieldn).ystd = ystd;
				outs.(fieldn).yse = ystderr;
				outs.(fieldn).yci = yci;
				outs.(fieldn).xcolout = xcolout;
				outs.(fieldn).ycolout = ycolout;
				outs.(fieldn).text = t;
				
				%set(gcf,'Renderer','zbuffer');
				
				fprintf('\n---> getDensity Computation time took: %.2g seconds\n',toc);
				
				obj.pn = pn;
				
				if obj.singleplots == true
					obj.doSinglePlots(pn);
				end
				
				if isDataEqualLength && ~isempty(uniquecases) && ~isempty(casesLocal)
					for jj = 1:length(uniquecases)
						caseidx = ismember(casesLocal,uniquecases{jj});
						xtmp = xcol(caseidx);
						ytmp = ycol(caseidx);
						name = ['Case_' uniquecases{jj}];
						otmp = obj.toStructure();
						otmp.x = xtmp;
						otmp.y = ytmp;
						otmp.cases = cell(0,0);
						otmp.columnlabels{1} = [otmp.columnlabels{i} ' ' name];
						otmp.autorun = false;
						otmp.verbose = false;
						gdtmp = getDensity(otmp);
						outtmp = gdtmp.run;
						outs.(fieldn).(name)=outtmp;
					end
					figure(outs.(fieldn).h);
				end
			end
			obj.runStructure = outs;
		end
		
		% ===================================================================
		%> @brief
		%>
		%> @param obj this instance object
		% ===================================================================
		function scatterColumns(obj,c1,c2)
			
			obs1 = obj.xdata.Properties.VarNames{c1};
			obs2 = obj.xdata.Properties.VarNames{c2};
			
			d1 = obj.xdata.(obs1);
			d2 = obj.xdata.(obs2);
			d3 = obj.ydata.(obs1);
			d4 = obj.ydata.(obs2);
			
			if obj.addjitter == true
				obj.addjitter = 'both';
			end
			switch obj.addjitter
				case 'x'
					sc = true;
					d1 = obj.jitterData(d1);
					d3 = obj.jitterData(d3);
				case 'y'
					sc = true;
					d2 = obj.jitterData(d2);
					d4 = obj.jitterData(d4);
				case 'equal'
					sc = true;
					[d1, jitter] = obj.jitterData([d1 d3]);
					d3 = obj.jitterData([d3 d1],jitter);
					[d2, jitter] = obj.jitterData([d2 d4]);
					d4 = obj.jitterData([d4 d2],jitter);
				case 'both'
					sc = true;
					d1 = obj.jitterData(d1);
					d3 = obj.jitterData(d3);
					d2 = obj.jitterData(d2);
					d4 = obj.jitterData(d4);
				otherwise
					sc = false;
			end
			
			h=figure;
			figpos(1,[1000,1000]);
			set(h,'Color',[1 1 1]);
			hold on
			scatter(d1, d2, repmat(80,length(d1),1),[0 0 0],'MarkerFaceColor','none',...
				'DisplayName',obj.legendtxt{1});
			scatter(d3, d4, repmat(80,length(d3),1),[0.8 0 0],'MarkerFaceColor','none',...
				'DisplayName',obj.legendtxt{2});
			set(gca, 'FontSize', 14);
			hold off
			box on
			grid on
			xlabel([obs1])
			ylabel([obs2])
			title(['Scatterbox plot comparing ' obs1 ' against ' obs2 ' -- jitter:' obj.addjitter]);
		end
		
		% ===================================================================
		%> @brief
		%>
		%> @param obj this instance object
		% ===================================================================
		function [data,jitter] = jitterData(obj,datain,jitter)
			
			if ~exist('jitter','var')
				jitter = [];
			end
			
			if size(datain,2) > size(datain,1)
				datain = datain';
			end
			
			if size(datain,2) > 1
				
				other = datain(:,2);
				datain = datain(:,1);
				range1 = max(datain) - min(datain);
				range2 = max(other) - min(other);
				if isempty(jitter)
					jitter = (randn(length(datain),1))*(max(range1,range2)/obj.jitterfactor);
				end
			else
				range = max(datain) - min(datain);
				if isempty(jitter)
					jitter = (randn(length(datain),1))*(range/obj.jitterfactor);
				end
			end
			
			data = datain + jitter;
			
		end
		
		% ===================================================================
		%> @brief
		%>
		%> @param obj this instance object
		% ===================================================================
		function value = get.nColumns(obj)
			value = size(obj.x,2);
		end
		
		% ===================================================================
		%> @brief
		%>
		%> @param obj this instance object
		% ===================================================================
		function value = get.isDataEqualLength(obj)
			if size(obj.x,1) == size(obj.y,1)
				value = true;
			else
				value = false;
			end
		end
		
		% ===================================================================
		%> @brief
		%>
		%> @param obj this instance object
		% ===================================================================
		function value = get.plotX(obj)
			if obj.isDataEqualLength
				value = 3;
			else
				value = 3;
			end
		end
		
		% ===================================================================
		%> @brief
		%>
		%> @param obj this instance object
		% ===================================================================
		function value = get.plotY(obj)
			if obj.isDataEqualLength
				value = 2;
			else
				value = 2;
			end
		end
		
		% ===================================================================
		%> @brief
		%>
		%> @param obj this instance object
		% ===================================================================
		function value = get.uniquecases(obj)
			if ~isempty(obj.cases)
				value = getlabels(obj.cases);
			else
				value = [];
			end
		end
		
		% ===================================================================
		%> @brief
		%>
		%> @param obj this instance object
		% ===================================================================
		function set.x(obj,value)
			if isstruct(value) && length(value) == 1
				f = fieldnames(value);
				firstLength = [];
				x = [];
				names = {};
				for i = 1:length(f)
					col = value.(f{i});
					if isnumeric(col) && isvector(col)
						if ~iscolumn(col)
							col = col';
						end
						if isempty(firstLength)
							firstLength = length(col);
						end
						if length(col) == firstLength
							x(:,end+1) = col;
							names{end+1} = f{i};
						end
					end
				end
				if ~isempty(x)
					obj.x = x;
					obj.columnlabels = names;
				end
			elseif isnumeric(value)
				if ~iscolumn(value)
					value=value';
				end
				value(isnan(value)) = []; %purge nans
				obj.x = value;
			else
				warning('x input data isn''t valid, must be a vector or a structure of vectors')
			end
			notify(obj,'checkData');
		end
		
		% ===================================================================
		%> @brief
		%>
		%> @param obj this instance object
		% ===================================================================
		function set.y(obj,value)
			if isstruct(value) && length(value) == 1
				f = fieldnames(value);
				firstLength = [];
				x = [];
				names = {};
				for i = 1:length(f)
					col = value.(f{i});
					if isnumeric(col) && isvector(col)
						if ~iscolumn(col)
							col = col';
						end
						if isempty(firstLength)
							firstLength = length(col);
						end
						if length(col) == firstLength
							x(:,end+1) = col;
							names{end+1} = f{i};
						end
					end
				end
				if ~isempty(x)
					obj.y = x;
					obj.columnlabels = names;
				end
			elseif isnumeric(value)
				if ~iscolumn(value)
					value=value';
				end
				value(isnan(value)) = []; %purge nans
				obj.y = value;
			end
			
			notify(obj,'checkData');
		end
		
		% ===================================================================
		%> @brief
		%>
		%> @param obj this instance object
		% ===================================================================
		function set.columnlabels(obj,value)
			if ischar(value)
				obj.columnlabels = {value};
			elseif iscell(value)
				obj.columnlabels = value;
			end
			
			notify(obj,'checkData');
		end
		
		% ===================================================================
		%> @brief
		%>
		%> @param obj this instance object
		% ===================================================================
		function set.cases(obj,value)
			if length(value) ~= length(obj.x(:,1))
				obj.cases = [];
			else
				if size(value,2) > size(value,1)
					value = value';
				end
				for ii = 1:length(value)
					if isempty(value{ii})
						value{ii} = 'Unknown';
					end
					value{ii}=regexprep(value{ii},'^\?$','Unknown');
					value{ii}=regexprep(value{ii},'\W','_');
				end
				if obj.nominalcases == true
					obj.cases = nominal(value);
				else
					obj.cases = ordinal(value);
				end
			end
			notify(obj,'checkData');
		end
		
		% ===================================================================
		%> @brief
		%>
		%> @param obj this instance object
		% ===================================================================
		function ret = haveData(obj)
			if isempty(obj.x)
				ret = false;
			else
				ret = true;
			end
		end
		
		% ===================================================================
		%> @brief
		%>
		%> @param obj this instance object
		% ===================================================================
		function doSinglePlots(obj,pn)
			if ~exist('pn','var');pn = obj.pn;end
			wid = 1000;
			hei = 800;
			minp = 0.01;
			maxp = 0.925;
			if obj.isDataEqualLength;
				h = figure;
				figpos(1,[wid hei]);
				set(h,'Color',[0.9 0.9 0.9])
				p = copyobj(pn(1,1).axis,h, 'legacy');
				set(p,'Units','Normalized','OuterPosition',[minp minp maxp maxp]);
				set(gcf,'Renderer','painters');
				
				h = figure;
				figpos(1,[wid hei]);
				set(h,'Color',[0.9 0.9 0.9])
				p = copyobj(pn(1,2).axis,h, 'legacy');
				set(p,'Units','Normalized','OuterPosition',[minp minp maxp maxp]);
				%set(gcf,'Renderer','zbuffer');
				
				h = figure;
				figpos(1,[wid hei]);
				set(h,'Color',[0.9 0.9 0.9])
				p = copyobj(pn(1,3).axis,h, 'legacy');
				set(p,'Units','Normalized','OuterPosition',[minp minp maxp maxp]);
				set(gcf,'Renderer','painters');
				
				h=figure;
				figpos(1,[wid hei]);
				set(h,'Color',[0.9 0.9 0.9])
				p = copyobj(pn(2,1).axis,h, 'legacy');
				set(p,'Units','Normalized','OuterPosition',[minp minp maxp maxp]);
				set(gcf,'Renderer','painters');
				
				h=figure;
				figpos(1,[wid hei]);
				set(h,'Color',[0.9 0.9 0.9])
				p = copyobj(pn(2,2).axis,h, 'legacy');
				set(p,'Units','Normalized','OuterPosition',[minp minp maxp maxp]);
				set(gcf,'Renderer','painters');
				
				h=figure;
				figpos(1,[wid hei]);
				set(h,'Color',[0.9 0.9 0.9])
				p = copyobj(pn(2,3).axis,h, 'legacy');
				set(p,'Units','Normalized','OuterPosition',[minp minp maxp maxp]);
				set(gcf,'Renderer','painters');
			else
				h = figure;
				figpos(1,[wid hei]);
				set(h,'Color',[0.9 0.9 0.9])
				p = copyobj(pn(1,1).axis,h, 'legacy');
				set(p,'Units','Normalized','OuterPosition',[minp minp maxp maxp]);
				set(gcf,'Renderer','painters');
				
				h = figure;
				figpos(1,[wid hei]);
				set(h,'Color',[0.9 0.9 0.9])
				p = copyobj(pn(1,2).axis,h, 'legacy');
				set(p,'Units','Normalized','OuterPosition',[minp minp maxp maxp]);
				%set(gcf,'Renderer','zbuffer');
				
				h = figure;
				figpos(1,[wid hei]);
				set(h,'Color',[0.9 0.9 0.9])
				p = copyobj(pn(1,3).axis,h, 'legacy');
				set(p,'Units','Normalized','OuterPosition',[minp minp maxp maxp]);
				set(gcf,'Renderer','painters');
				
				h = figure;
				figpos(1,[wid hei]);
				set(h,'Color',[0.9 0.9 0.9])
				p = copyobj(pn(2,1).axis,h, 'legacy');
				set(p,'Units','Normalized','OuterPosition',[minp minp maxp maxp]);
				set(gcf,'Renderer','painters');
				
				h = figure;
				figpos(1,[wid hei]);
				set(h,'Color',[0.9 0.9 0.9])
				p = copyobj(pn(2,2).axis,h, 'legacy');
				set(p,'Units','Normalized','OuterPosition',[minp minp maxp maxp]);
				set(gcf,'Renderer','painters');
				
			end
		end
	end
	
	%=======================================================================
	methods ( Access = private ) %-------PRIVATE METHODS-----%
		%=======================================================================
		
		% ===================================================================
		%> @brief Function that runs after the checkData event fires
		%>
		%> @param obj this instance object
		% ===================================================================
		function doCheckData(obj, src, evnt)
			obj.salutation([evnt.EventName ' event'],'Event is running...',true);
			if isempty(obj.y)
				obj.y = zeros(size(obj.x));
			end
			if size(obj.x,2) > length(obj.columnlabels)
				for i = length(obj.columnlabels)+1 : size(obj.x,2)
					obj.columnlabels{i} = ['DataSet' num2str(i)];
				end
			end
			if isempty(obj.cases) && ~isempty(obj.uniquecases)
				obj.uniquecases = [];
			end
			if isempty(obj.xrownames) || (length(obj.x) ~= length(obj.xrownames))
				ntmp = cell(length(obj.x),1);
				for i = 1:length(obj.x)
					ntmp{i} = ['Obs_' num2str(i)];
				end
				obj.xrownames = ntmp;
			end
			if isempty(obj.yrownames) || (length(obj.y) ~= length(obj.yrownames))
				ntmp = cell(length(obj.y),1);
				for i = 1:length(obj.y)
					ntmp{i} = ['Obs_' num2str(i)];
				end
				obj.yrownames = ntmp;
			end
			if ~isempty(obj.x)
				if ~isempty(obj.cases) && obj.isDataEqualLength
					obj.xdata = dataset({obj.x,obj.columnlabels{:}},'ObsNames',obj.xrownames);
					ntmp = dataset({obj.cases,'Groups'});
					obj.xdata = horzcat(obj.xdata, ntmp);
				else
					obj.xdata = dataset({obj.x,obj.columnlabels{:}},'ObsNames',obj.xrownames);
				end
			end
			if ~isempty(obj.y)
				if ~isempty(obj.cases) && obj.isDataEqualLength
					obj.ydata = dataset({obj.y,obj.columnlabels{:}},'ObsNames',obj.yrownames);
					ntmp = dataset({obj.cases,'Groups'});
					obj.ydata = horzcat(obj.ydata, ntmp);
				else
					obj.ydata = dataset({obj.y,obj.columnlabels{:}},'ObsNames',obj.yrownames);
				end
			end
			if length(obj.index) > size(obj.x,2)
				obj.index = [];
			end			
		end
		
		% ===================================================================
		%> @brief
		%>
		%> @param obj this instance object
		% ===================================================================
		function [xcol,ycol,cases,xouttext,youttext] = removeOutliers(obj,xcol,ycol,cases,xouttext,youttext)
			xmean=nanmean(xcol); %initial values before outlier removal
			ymean=nanmean(ycol);
			xstd=nanstd(xcol);
			ystd=nanstd(ycol);
			switch obj.dooutlier
				case 'limit'
					idx1=find(xcol > obj.outlierlimit);
					idx2=find(ycol > obj.outlierlimit);
					if ~isempty(idx1) || ~isempty(idx2)
						if length(xcol)==length(ycol)
							idx=unique([idx1;idx2]);
							xouttext=sprintf('%0.3g ',xcol(idx)');
							youttext=sprintf('%0.3g ',ycol(idx)');
							xcol(idx)=[];
							ycol(idx)=[];
							if ~isempty(cases); cases(idx)=[]; end
						else
							if length(idx1)+2 < length(xcol)
								xouttext=sprintf('%0.3g ',xcol(idx1)');
								xcol(idx1)=[];
							end
							if length(idx2)+2 < length(ycol)
								youttext=sprintf('%0.3g ',ycol(idx2)');
								ycol(idx2)=[];
							end
						end
					end
				case 'quantiles'
					idx1=qoutliers(xcol);
					idx2=qoutliers(ycol);
					if length(xcol)==length(ycol)
						idx=idx1+idx2;
						xouttext=sprintf('%0.3g ',xcol(idx>0)');
						youttext=sprintf('%0.3g ',ycol(idx>0)');
						xcol(idx>0)=[];
						ycol(idx>0)=[];
						cases(idx>0)=[];
					else
						xouttext=sprintf('%0.3g ',xcol(idx1>0)');
						youttext=sprintf('%0.3g ',ycol(idx2>0)');
						xcol(idx1>0)=[];
						ycol(idx2>0)=[];
					end
				case 'rosner'
					idx1=outlier(xcol,obj.outlierp,obj.rosnern);
					idx2=outlier(ycol,obj.outlierp,obj.rosnern);
					if ~isempty(idx1) || ~isempty(idx2)
						if length(xcol)==length(ycol)
							idx=unique([idx1;idx2]);
							xouttext=sprintf('%0.3g ',xcol(idx)');
							youttext=sprintf('%0.3g ',ycol(idx)');
							xcol(idx)=[];
							ycol(idx)=[];
							if ~isempty(cases); cases(idx)=[]; end
						else
							xouttext=sprintf('%0.3g ',xcol(idx1)');
							youttext=sprintf('%0.3g ',ycol(idx2)');
							xcol(idx1)=[];
							ycol(idx2)=[];
						end
					end
				case 'grubb'
					[~,idx1]=deleteoutliers(xcol,obj.outlierp);
					[~,idx2]=deleteoutliers(ycol,obj.outlierp);
					if length(xcol)==length(ycol)
						idx=unique([idx1;idx2]);
						xouttext=sprintf('%0.3g ',xcol(idx)');
						youttext=sprintf('%0.3g ',ycol(idx)');
						xcol(idx)=[];
						ycol(idx)=[];
						if ~isempty(cases); cases(idx)=[]; end
					else
						xouttext=sprintf('%0.3g ',xcol(idx1)');
						youttext=sprintf('%0.3g ',ycol(idx2)');
						xcol(idx1)=[];
						ycol(idx2)=[];
					end
				case '2SD'
					mtmp=repmat(xmean,length(xcol),1);
					stmp=repmat(xstd,length(xcol),1);
					idx1=abs(xcol-mtmp)>2*stmp;
					
					mtmp=repmat(ymean,length(ycol),1);
					stmp=repmat(ystd,length(ycol),1);
					idx2=abs(ycol-mtmp)>2*stmp;
					if length(xcol)==length(ycol)
						idx=idx1+idx2;
						xouttext=sprintf('%0.3g ',xcol(idx>0)');
						youttext=sprintf('%0.3g ',ycol(idx>0)');
						xcol(idx>0)=[];
						ycol(idx>0)=[];
						if ~isempty(cases); cases(idx>0)=[]; end
					else
						xouttext=sprintf('%0.3g ',xcol(idx1>0)');
						youttext=sprintf('%0.3g ',ycol(idx2>0)');
						xcol(idx1>0)=[];
						ycol(idx2>0)=[];
					end
				case '3SD'
					mtmp=repmat(xmean,length(xcol),1);
					stmp=repmat(xstd,length(xcol),1);
					idx1=abs(xcol-mtmp)>3*stmp;
					
					mtmp=repmat(ymean,length(ycol),1);
					stmp=repmat(ystd,length(ycol),1);
					idx2=abs(ycol-mtmp)>3*stmp;
					if length(xcol)==length(ycol)
						idx=idx1+idx2;
						xouttext=sprintf('%0.3g ',xcol(idx>0));
						youttext=sprintf('%0.3g ',ycol(idx>0));
						xcol(idx>0)=[];
						ycol(idx>0)=[];
						if ~isempty(cases); cases(idx>0)=[]; end
					else
						xouttext=sprintf('%0.3g ',xcol(idx1>0));
						youttext=sprintf('%0.3g ',ycol(idx2>0));
						xcol(idx1>0)=[];
						ycol(idx2>0)=[];
					end
				otherwise
					
			end
		end
		
		% ===================================================================
		%> @brief Converts properties to a structure
		%>
		%>
		%> @param obj this instance object
		%> @return out the structure
		% ===================================================================
		function out=toStructure(obj)
			out = struct();
			fn = fieldnames(obj);
			for j=1:length(fn)
				out.(fn{j}) = obj.(fn{j});
			end
		end
		
		% ===================================================================
		%> @brief Prints messages dependent on verbosity
		%>
		%> Prints messages dependent on verbosity
		%> @param obj this instance object
		%> @param in the calling function
		%> @param message the message that needs printing to command window
		% ===================================================================
		function salutation(obj,in,message,force)
			if ~exist('force','var'); force = false; end
			if obj.verbose==true || force == true
				if ~exist('in','var')
					in = 'undefined';
				end
				if exist('message','var')
					fprintf(['---> getDensity: ' message ' | ' in '\n']);
				else
					fprintf(['---> getDensity: ' in '\n']);
				end
			end
		end
		
		% ===================================================================
		%> @brief Converts properties to a structure
		%>
		%>
		%> @param obj this instance object
		%> @return out the structure
		% ===================================================================
		function [avg,error] = stderr(obj,data,type,onlyerror)
			avg=nanmean(data);
			if nargin<4
				onlyerror=0;
			end
			if nargin<3
				type='SE';
			end
			
			if size(type,1)>1
				type=reshape(type,1,size(type,1));
			end
			
			switch(type)
				
				case 'SE'
					err=nanstd(data);
					error=sqrt(err.^2/length(data));
				case '2SE'
					err=nanstd(data);
					error=sqrt((err.^2/length(data)))*2;
				case 'SD'
					error=nanstd(data);
				case '2SD'
					error=(nanstd(data))*2;
				case '3SD'
					error=(nanstd(data))*3;
				case 'V'
					error=nanstd(data).^2;
				case 'F'
					if max(data)==0
						error=0;
					else
						error=nanvar(data)/nanmean(data);
					end
				case 'C'
					if max(data)==0
						error=0;
					else
						error=nanstd(data)/nanmean(data);
					end
				case 'A'
					if max(data)==0
						error=0;
					else
						error=nanvar(diff(data))/(2*nanmean(data));
					end
			end
			
			if onlyerror==1
				avg=error;
			end
		end
		
		
		% ===================================================================
		%> @brief Sets properties from a structure or normal arguments,
		%> ignores invalid properties
		%>
		%> @param args input structure
		%> @param allowedProperties properties possible to set on construction
		% ===================================================================
		function parseArgs(obj, args, allowedProperties)
			
			%lets make allowedProperties from the class properties
			if ~exist('allowedProperties','var') || isempty(allowedProperties)
				ptmp = properties(mfilename);
				otmp = '';
				for i = 1:length(ptmp)
					if isempty(regexpi(ptmp{i},obj.ignoreProperties))
						if i == 1
							otmp = ptmp{i};
						else
							otmp = [otmp '|' ptmp{i}];
						end
					end
				end
				allowedProperties = otmp;
			end
			
			allowedProperties = ['^(' allowedProperties ')$'];
			
			while iscell(args) && length(args) == 1
				args = args{1};
			end
			
			if iscell(args)
				if mod(length(args),2) == 1 % odd
					args = args(1:end-1); %remove last arg
				end
				odd = logical(mod(1:length(args),2));
				even = logical(abs(odd-1));
				args = cell2struct(args(even),args(odd),2);
			end
			
			if isstruct(args)
				fnames = fieldnames(args); %find our argument names
				for i=1:length(fnames);
					if ~isempty(regexp(fnames{i},allowedProperties, 'once')) && isempty(regexp(fnames{i},obj.ignoreProperties, 'once')) %only set if allowed property
						obj.salutation(fnames{i},'Configuring setting in constructor');
						obj.(fnames{i})=args.(fnames{i}); %we set up the properies from the arguments as a structure
					end
				end
			end
			
		end
		
	end
	
end

